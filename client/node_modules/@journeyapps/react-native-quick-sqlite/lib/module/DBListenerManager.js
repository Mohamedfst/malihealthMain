"use strict";

import { registerTransactionHook, registerUpdateHook } from './table-updates';
import { TransactionEvent } from './types';
import { BaseObserver } from './utils/BaseObserver';
export class DBListenerManager extends BaseObserver {}
export class DBListenerManagerInternal extends DBListenerManager {
  constructor(options) {
    super();
    this.options = options;
    this.updateBuffer = [];
    registerUpdateHook(this.options.dbName, update => this.handleTableUpdates(update));
    registerTransactionHook(this.options.dbName, eventType => {
      switch (eventType) {
        /**
         * COMMIT hooks occur before the commit is completed. This leads to race conditions.
         * Only use the rollback event to clear updates.
         */
        case TransactionEvent.ROLLBACK:
          this.transactionReverted();
          break;
      }
      this.iterateListeners(l => l.writeTransaction?.({
        type: eventType
      }));
    });
  }
  flushUpdates() {
    if (!this.updateBuffer.length) {
      return;
    }
    const groupedUpdates = this.updateBuffer.reduce((grouping, update) => {
      const {
        table
      } = update;
      const updateGroup = grouping[table] || (grouping[table] = []);
      updateGroup.push(update);
      return grouping;
    }, {});
    const batchedUpdate = {
      groupedUpdates,
      rawUpdates: this.updateBuffer,
      tables: Object.keys(groupedUpdates)
    };
    this.updateBuffer = [];
    this.iterateListeners(l => l.tablesUpdated?.(batchedUpdate));
  }
  transactionReverted() {
    // clear updates
    this.updateBuffer = [];
  }
  handleTableUpdates(notification) {
    // Fire updates for any change
    this.iterateListeners(l => l.rawTableChange?.({
      ...notification
    }));

    // Queue changes until they are flushed
    this.updateBuffer.push(notification);
  }
}
//# sourceMappingURL=DBListenerManager.js.map